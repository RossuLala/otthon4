/ *!

Tartó - az ügyfél oldali kép helyőrzői
2.6.0 verzió + 51ebp
© 2015 Ivan Malopinsky - http://imsky.co

Webhely: http://holderjs.com
Kérdések: https://github.com/imsky/holder/issues
Licenc: http://opensource.org/licenses/MIT

* /
! function (a, b) {"object" == export típusa és & "objektum" == típusú modul = module.exports = b (): "function" == typeof define && define.amd? define (b) = a export típusa: exports.Holder = b (): a.Holder = b ()} (ez, függvény () {return függvény (a) {függvény b (d) {if (c [d] ] .exports; var e = c [d] = {export: {}, id: d, betöltve:! 1}; visszaad egy [d] .call (e.exports, e, e.exports, b), e (függvény (a, b, c) {(függvény (b (b) ) {függvény d (a, b, c, d) {var g = e (c.substr (c.lastIndexOf (a.domain)), a), g && f , motorSettings: b})} függvény e (a, b) {for (var c = {téma: y (K.settings.themes.gray, null), stíluslapok: b.stíluslapok, holderURL: []}, d = ! 1, e = String.fromCharCode (11), f = a.replace (/ ([^ \\]) \ // g, "$ 1" + e) ​​.split (e), g = /% [0- 9a-f] {2} /gi,h=f.length,i=0;h> i;(j) (j) (j) (j) f (i) = if (jmatch (g)) {j = decodeURIComponent (j)} fog (k) {j = f [i]} var l = .flags.dimensions.match (j)) d =! 0, c.dimensions = K.flags.dimensions.output (j), l =! 0; egyébként ha (K.flags.fluid.match (j)) d =! 0, c.dimensions = K.flags.fluid.output (j), c.fluid =! 0, l =! 0; egyébként ha (K.flags.textmode.match (j)) c.textmode = K ha a (K.flags.colors.match (j)) {var m = K.flags.colors.output (j); c.theme = y (.flags.textmode.output (j), l =! 0; (b.themes [j]) b.themes.hasOwnProperty (j) && (c.theme = y (b.themes [j], null)), l =! 0; egyébként ha (K.flags.font.match (j)) c.font = K.flags.font.output (j), l =! 0; egyébként ha (K.flags.auto.match (j )) c.auto =! 0, l =! 0; egyébként ha (K.flags.text.match (j)) c.text = K.flags.text.output (j), l =! 0; (K.flags.size.match (j)) c.size = K.flags.size.output (j), l =! 0; egyébként ha (K.flags.random.match (j)) {null == K.vars.cache.themeKeys && (K.vars.cache.themeKeys = Object.kulcsok (b.themes)); var n = K.vars.cache.themeKeys [0 | Math.random () * K.vars.cache.themeKeys.length]; c.theme = y (b.themes [n] , null), l =! 0} l && c.holderURL.push (j)} visszaadni c.holderURL.unshift (b.domain), c.holderURL = c.holderURL.join ("/"), d? c :! 1} függvény f (a) {var b = a.mode, c = a.el, d = a.flags, e = a.engineSettings, f = d.dimensions, h = d.theme, i = f.width + "x" + f.height; ha (b = null == b? d.fluid? "fluid": "kép": b, null! = d.text && (h.text = d.text, "tárgy" = == c.nodeName.toLowerCase ())) {a (var l = h.text.split ("\\ n"), m = 0; m <l.hossz; m ++) l [m] = A (d.font && (h.font = d.font, d.font = d.font.html); h.text = l.join ("\\ n")} var n = d.holderURL, ! o.noFontFallback && "img" === c.nodeName.toLowerCase () && K.setup.supportsCanvas && "svg" === o.renderer && (O = y (O, {renderelő:”vászon "}))), d.font &&" vászon "== o.renderer && (o.reRender =! 0)," háttér "== b) null == c.getAttribute (" adat-háttér-src ") && p (c, {"adat-háttér-src": n}); egyébként {var q = {}; q [K.vars.dataAttr] = n, p (c, q)} d.theme = h, c. holder == b) && p (c, {alt: h.text? h.text + "[" + i + "]" msgstr " var} = {mód: b, el: c, holderBeállítások: {dimenziók: f, téma: h, zászlók: d}, engineSettings: o}, "image" == b? ("html"! = o.renderer && d.auto || (c.style.width = f.width + "px", c.style.height = f.height + "px"), "html" == o.renderer? c.style.backgroundColor = h.background: (g (R), "pontos" == d.textmode && (c.holderData.resizeUpdate =! 0, K.vars.resizableImages.push (c), j (c)))): "háttér "== b && "html"! = O.renderer? G (R): "fluid" == b && (c.holderData.resizeUpdate =! 0, "%" == f.height.slice (-1)? C. style.height = f.height: null! = d.auto && d.auto || (c.style.height = f.height + "px"), "%" == f.width.slice (-1)? c. style.width = f.width: null! = d.auto && d.auto || (c.style.width = f.width + "px") ( "inline" == c.style.display || "" == = c.style.display || "none" == c.style.display) && (c.style.display = "blokk"), k (c), a "HTML" == o.renderer? c.style. (c), függvény (c)) függvény g (a) {függvény c () {var b = null; kapcsoló (i.renderer) {case " v: "b = M (k, a), szünet, eset" svg ": b = N (k, a), törés, alapértelmezett: dobás" Tartó: érvénytelen renderer: "+ i.renderer} = null, e = a.mode, f = a.holderSettings, g = a.el, i = a.engineSettings; kapcsolót (i.renderer) {case "svg": ha (! K.setup.supportsSVG) visszatérési; break; esetben "vászon": ha (! K.setup .supportsCanvas) return; break; alapértelmezett: return} var j = {szélesség: f.dimensions.width, magasság: f.dimensions.height, téma: f.theme, zászlók: f.flags}, k = h (j) ha (d = c (), null == d) dobja a "Holder: nem tud helyet adni"; "background" == e? (g.style.backgroundImage = "url (" + d + ") (objektum) = "j" = "j" = "j" = j.width + "px" + j.height + "px") :( "img" === g.nodeName.toLowerCase == g.nodeName.toLowerCase () && (p (g, {adatok: d}), p (g, {típusa: "image / sVG + xml"})), i.reRender && b.setTimeout (function () { var a = c (), ha (null == a) dobja a "Tartó: nem tud helyet adni"; "img" === g.nodeName.toLowerCase ()? p (g, {src:a}): "tárgy" === g.nodeName.toLowerCase () && (p (g, {adatok: a}), p (g, {típusa: "image / SVG + xml"}))}, 100 ) {függvény b (a, b, c, d) {b.width = c, b.height = d , a.width = Math.max (a.width, b.width), a.height + = b.height, a.add (b)} var c = K.defaults.size; kapcsoló (parseFloat (a.theme. mérete)? c = a.theme.size: parseFloat (a.flags.size) && (c = a.flags.size), a.font = {család: a.theme.font? a.theme.font:” Arial, Helvetica, Open Sans, sans-serif ", méret: i (a.width, a.height, c), egységek: a.theme.units? A.theme.units: K.defaults.units, weight: a .theme.fontweight? a.theme.fontweight: "Bold"}, a.text = a.theme.text? a.theme.text: Math.floor (a.width) + "x" + Math.floor (a .height), a.flags.textmode) {case "szó": a.text = a.flags.dimensions.width + "x" + a.flags.dimensions.height; break; esetben”pontos ": ha (! a.flags.exactDimensions) break; a.text = Math.floor (a.flags.exactDimensions.width) +" x "+ Math.floor (a.flags.exactDimensions.height)} var d = új w ({szélesség: a.width, magasság: a.height}), e = d.Shape, f = új e.Rect ("holderBg", {fill: a.theme.background}); var g = új e.Group ("holderTextGroup", {text: a.text, igazítás: "center", betűtípus: a.font, a.feot), d.root.add (f) (a) a géptől függően (g), g.textPositionData = L (d), ha (! h) dobja a "Holder : a függvény megtartása még nem támogatott "; g.properties.leading = h.boundingBox.height; var j = null, k = null; ha (h.lineCount> 1) {var l = 0, m = 0, n = a.width * K.setup.lineWrapRatio, o = 0; k = új e.Group ("line" + o); a (var p = 0; p <h.words.length; p ++) {var q = h .word [p]; j = új e.Text (q.text); var r = "\\ n" == q.text; (l + q.width> = n || r ===!0, m + = g.properties.leading, o + = 1, k = új e.Group ("line" + o), ky = m), r! ==! 0 && (j.moveTo (l, 0), L + = h.spaceWidth + q.width, k.add (j))} b (g, K, L, g.properties. k = g.children [s], k.moveTo ((szélesség-k.width) / 2, null, null); g.moveTo ((a.width -g.width) / 2, (a.height-g.height) / 2, null), (a.height-g.height) / 2 <0 && g.moveTo (null, 0, null)} else j = new e.Text (a.text), k = új e.Group ("line0"), k.add (j), g.add (k), g.moveTo ((a.width-h.boundingBox.width) /2,(a.height-h.boundingBox.height)/2,null);return d} i függvény (a, b, c) {var d = parseInt (a, 10), e = parseInt (b, 10 ), f = Math.max (d, e), g = Math.min (d, e), h = 8 * Math.min (g, f * K.defaults.scale) .max (c, h))} függvény j (a) {var b; b = null == a || null == a.nodeType? K.vars.resizableImages: [a], a (var c = 0, d = b.hossz; d> c; c ++) {var e = b [c]; ha (pl.holddData.flags, h = E (e), ha (h) {ha (! e.holderData.resizeUpdate) folytatódik, ha (f.fluid && f.auto) {var i = e.holderData .fluidConfig; kapcsoló (i.mode) {eset "szélesség": h.height = h.width / i.ratio; törés; eset "magasság": h.width = h.height * i.ratio}} var j = {mód: "kép", holderSettings: {méretei: H, téma: f.theme, zászlók: f}, El: e, engineSettings: e.holderData.engineSettings}; "pontos" == f.textmode && (f.exactDimensions = h, j.holderSettings.dimensions = f.dimensions), g (j)} else n (e)}}} függvény k (a) {if (a.holderData) {var b = E (a); b) {var c = a.holderData.flags, d = {fluidHeight: "%" == c.dimensions.height.slice (-1), fluidWidth: "%" == c.dimensions.width.slice (- 1), mód: null, initialDimensions: b}; d.fluidWidth &&! d.fluidHeight? (d.mode = "szélesség", d.ratio = d.initialDimensions.width / parseFloat (C minőségben.magasság)): d.fluidWidth && d.fluidHeight && (d.mode = "magasság", d.ratio = parseFloat (c.dimensions.width) /d.initialDimensions.height), a.holderData.fluidConfig = d} else n a)}} függvény l () {for (var a, c = [], d = Object.keys (K.vars.invisibleImages), e = 0, f = d.length; f> e; K.vars.invisibleImages [d [e]], E (a) && "img" == a.nodeName.toLowerCase () && (c.push (a), törölje K.vars.invisibleImages [d [e] ) c.length && J.run ({images: c}), b.requestAnimationFrame (l)} függvény m () {K.vars.visibilityCheckStarted || (b.requestAnimationFrame (l), K.vars.visibilityCheckStarted =! 0 }} függvény n (a) {a.holderData.invisibleId || (K.vars.invisibleId + = 1, K.vars.invisibleImages ["i" + K.vars.invisibleId] = a, a.holderData.invisibleId = K .vars.invisibleId)} függvény o (a, b) {return null == b? dokumentum.createElement (a): document.createElementNS (b, a)} függvény p (a,b) {a (z) (var c in b) a.setAttribute (c, b [c])} függvény q (a, b, c) {var d, e; , F), d = O ( "defs", F), e = O ( "stílusú", F), p (e, {típusa: "text / css"}), d.appendChild (e), a. appendChild (d)): e = a.querySelector ("stílus"), a.webkitMatchesSelector && a.setAttribute ("xmlns", F), a (var f = 0; f <a.childNodes.length; f ++) a.childNodes [f] .nodeType === G && a.removeChild (a.childNodes [f]); a (; e.childNodes.length;) e.removeChild (e.childNodes [0]); visszatérés p (a, {width: b, magasság: c, viewBox: "0 0" + b + "" + c, preserveAspectRatio: "none"}), a} függvény r (a, c) {if (b.XMLSerializer) {var d = e = "", f = c.stylesheets; ha (c.svgXMLStylesheet) {a (var g = s (), h = f.length-1; h> = 0; h -) {var i = g. createProcessingInstruction ( "XML-stylesheet", "href = " '+ f [H] +'"var = jlg.createProcessingInstruction ("xml", "verzió =" 1.0 "encoding =" UTF-8 "standalone =" yes "'), g.insertBefore (i, g.firstChild) ; g.insertBefore (j, g.firstChild), g.removeChild (g.documentElement), e = d.serializeToString (g)} var k = d.serializeToString (a); visszatérés k = k.hely (/ \ & amp () {Return b.DOMParser? (Új DOMParser) .parseFromString ("<xml void 0} függvény t (a) {K.vars.debounceTimer || a.call (ez), K.vars.debounceTimer && b.clearTimeout (K.vars.debounceTimer), K .vars.debounceTimer = b.setTimeout (függvény () {K.vars.debounceTimer = null, a.call (ez)}, K.setup.debounce)} függvény u () {t (függvény () {j (null }}}} var v = c (1), w = c (2), x = c (3), y = x.extend, z = x.cssProps, A = x.encodeHtmlEntity, B = x.decodeHtmlEntity, C = x.imageExists, D = x.getNodeArray, E = x.dimensionCheck, F = "http://www.w3.org/2000/svg", G = 8, H = "2.6.0", \ NTovábbi információ a http: //holderjs.com címen \ n (c) 2012-2015 Ivan Malopinsky - http: //imsky.co \ n ", J = { verzió: H, addTheme: függvény (a, b) {return null! = a && null! = b && (K.settings.themes [a] = b), törölje a K.vars.cache.themeKeys, ezt}, addImage: a (var d = 0, e = c.length; e> d; d ++) {var f = o ("img") (var c = document.querySelectorAll (b) , g = {}; g [K.vars.dataAttr] = a, p (f, g), c [d] .appendChild (f)} ezt visszaadja, setResizeUpdate: függvény (a, b) {a.holderData && (a.holderData.resizeUpdate = !! b, a.holderData.resizeUpdate && j (a))}, fuss: függvény (a) {a = a || {}; var c = {}, g = y , a); K.vars.preempted =! 0, K.vars.dataAttr = g.dataAttr || K.vars.dataAttr, c.renderelő = g.renderer? g.renderer: K.setup.renderer, -1 === K.setup.renderers.join ( ""). indexOf (c.renderer) && (c.renderer = K.setup. támogatja a SVV-t? svg: K.setup.supportsCanvas? "vászon": "html"); var h = D (g.images), i = D (g.bgnodes), j = D (gststenolák), k = D (gobjektumok); c.stylesheets = [], c.svgXMLStylesheet =! 0, c.noFontFallback = g.noFontFallback? G.noFontFallback:! 1, a (var l = 0; l <j.length; l ++) {var m = j [l]; ha (m.attributes.rel && m.attributes.href && "stíluslap" == m.attributes.rel.value) {var n = m.attributes.href.value, p = o p.host + p.pathname + p.search; c.stylesheets.push (q)}} az (l = 0 ; l <i.length; l ++), ha (b.getComputedStyle) {var r = b.getComputedStyle (i [l], null) .getPropertyValue ("háttérkép"), s = i [l] .getAttribute (" adatok-háttér-src "),t = null; t = null == s? r: s; var u = null, v = "?" + g.domain + "/", ha (0 === t.indexOf (v)) u = t. szelet (1), x = w.match (/ ([^ () () (z) = (z) = z (z) = z (z) = z (x) (l = 0; l <k.length; l ++) {var A = k [l], B = {}; próbáld { B.data = A.getAttribute ("adat"), B.dataSrc = A.getAttribute (K.vars.dataAttr)} fogás (E) {} var F = null! = B.data && 0 === B.data. indexOf (g.domain), g = null! = B.dataSrc && 0 === B.dataSrc.indexOf (g.domain); F? d (g, C, B.data, A): g && d (g, C, B.dataSrc, A)} (l = 0; l <h.length; l ++) {var H = h [l], I = {}, próbáld {I.src = H.getAttribute ("src" I.dataSrc = H.getAttribute (K.vars.dataAttr), I.rendered = H.getAttribute ("adat-holder-rendered")} fogás (E) {} var J = null! = I.src, L = nulla!= I.dataSrc && 0 === I.dataSrc.indexOf (g.domain), M = null! = I.rendered && "igaz" == I.rendered; J? 0 === I.src.indexOf (g.domain )? d (g, C, I.src, H): L && (M? d (g, C, I.dataSrc, H) :! funkció (a, b, c, e, f) {C (a, funkció (a) {a || d (b, c, e, f)})} (I.src, g, C, I.dataSrc, H)): L && d (g, C, I.dataSrc, H) } return this}}, K = {beállítások: {domain: "holder.js", képek: "img", objektumok: "objektum", bgnodes: "body .holderjs", stylenodes: "head link.holderjs" : [], témák: {szürke: {háttér: "# EEEEEE", előtérben: "# AAAAAA"}, szociális: {háttér: "# 3a5a97", előtérben: "# FFFFFF"}, ipari: {háttér: "# 434A52" , előtérben: "# C2F200"}, ég: {háttér: "# 0D8FDB", előtérben: "# FFFFFF"}, szőlő: {háttér: "# 39DBAC", előtérben: "# 1E292C"}, láva:{Háttér: "# F8591A", előtérben: "# 1C2846"}}}, alapértelmezett: {mérete: 10, egységek: "PT", skála: 1/16}, zászlók: {méretei: {regexünk: / ^ (\ d +) x (\ d +) $ /, kimenet: függvény (a) {var b = ez.regex.exec (a); visszatérés {width: + b [1] folyadék: {regex: / ^ ([0-9] +%?) x ([0-9] +%?) $ /, kimenet: függvény (a) {var b = ez.regex.exec (a); visszatérési {szélesség: b [1], magasság: b [2]}}}, színek: {regexünk: / (?: # | \ ^) ([0-9A-f] {3,}) \ :(? : {| Var} = this.regex.exec (a); return {előtér: "#" + b (Return): {function: (a) {return this.regex.exec (a) [ 1] .replace ("\\ /", "/")}}, betűtípus: {regex: / font \: (. *) /, Output: függvény (a) {return this.regex.exec (a) 1)}}, automatikus: {regex: / ^ auto $ /}, szövegmód: {regex: / textmode \: (. *) / Kimenet: függvény (a) {return this.regex.exec (a) [1 ]}}, véletlenszerű: {regexünk: / ^ random $ /}, méret:{regex: / size \: (\ d +) / kimenet: függvény (a) {vissza ez.regex.exec (a) [1]}}}}, L = függvény () {var a = null, null, c = null; visszatérési függvény (d) {var e = d.root; ha (K.setup.supportsSVG) {var f =! 1, g = függvény (a) {return document.createTextNode (a)}; (null == a || a.parentNode! == document.body) && (f = 0), a = q (a, e.properties.width, e.properties.height), a.style.display = "blokk", f && (b = O ( "text", f), c = g (null), p (b, {x: 0}), b.appendChild (c), a.appendChild (b), a dokumentum .body.appendChild (a), a.style.visibility = "rejtett", a.style.position = "abszolút", a.style.top = "- 100%", a.style.left = "- 100% "); var h = e.children.holderTextGroup, i = h.properties; p (b, {y: i.font.size, stílus: z ({" font-weight ": i.font.weight" "size": i.font.size + i.font.units, "font-family": i.font.family})}), c.nodeValue = i.text; var j = b.getBBox ()k = Math.ceil (j.width / (e.properties.width * K.setup.lineWrapRatio)), l = i.text.split (""), m = i.text.match (/ \\ n / g), k + = null == m? 0: m.hossz, c.nodeValue = i.text.replace (/ [] + / g, ""); var n = b.getComputedTextLength () s = Math.round (r / Math.max (1, l.hossz-1)), t = [], ha (k> 1) {c.nodeValue = "", a (var u = 0; u <l.hossz; u ++) ha (0! == l [u] .hossz) {c.nodeValue = B (l [u]); var v = b.getBBox (); t.push ({ szöveg: l [u], szélesség: v.width})}} visszatérés a.style.display = "none", {spaceWidth: s, lineCount: k, boundingBox: j, szavak: t} (), Var = d (c) {null == b && (b = a.getContext ("2d")); var d = c .root; a.width = K.dpr (d.properties.width), a.height = K.dpr (d.properties.height), b.textBaseline = "középső", b.fillStyle = d.children.holderBg .properties.fill, b.fillRect (0,0, K.dpr (d.children.holderBg.szélesség), K.dpr (d.children.holderBg.height)); {var e = d.children.holderTextGroup; e.properties} b.font = e.properties.font.weight + "" + K.dpr (e .properties.font.size) + e.properties.font.units + "" + e.properties.font.family + ", monospace", b.fillStyle = e.properties.fill; a (var f in e.children) { var g = e.children [f]; a (var h in g.chren) {var i = g.children [h], j = K.dpr (e.x + g.x + ix), k = K b.fillText (i.properties.text, j, k)}} visszaadja a.toDataURL ("image / png" }}} (), N = függvény () {if (b.XMLSerializer) {var a = s (), c = q (null, 0,0), d = (var, g = c.querySelectorAll ("g"), függvény (b, e) {var f = b.root; q (c, f.properties.width, f.properties.height); , h = 0; h <g.hossz; h ++) g [h] .parentNode.removeChild (g [h]); var i = e.holderSettings.flags.holderURL, j = "holder_"ToString (16), k = o ("g", F), l = f.children.holderTextGroup, m = l (szám (új dátum) +32768+ (0 | 32768 * Math.random () .textPositionData, t = "#" + j + "szöveg {" + z ({fill: m.fill, "font-weight": m.font "font-family": m.font.family + ", monospace", "font-size": m.font.size + m.font.units}) + "}", u = a.createComment (" \ nForrás URL: "+ i + I), v = a.createCDATASection (t), w = c.querySelector (" stílus "), p (k, {id: j}), c.insertBefore (u, c. firstChild), w.appendChild (v), k.appendChild (d), k.appendChild (n), c.appendChild (k), p (d, {szélesség: f.children.holderBg.width, magasság: f. children.holderBg.height, töltse ki: f.children.holderBg.properties.fill}), l.y + = .8 * s.boundingBox.height; (var x in l.children) {var y = l.children [ x]; (var A a y.childrenben) {var B = y.children [A], C = l.x + y.x + Bx,D = l.y + y.y +, e = O ( "text", F), G = document.createTextNode (null); p (E, {x: C, y: D}), G.nodeValue = B.properties.text, E.appendChild (G), n.appendChild (E)}} var H = "adatok: image / svg + xml; base64," + btoa (unescape (encodeURIComponent (r (c, e. motorSettings)))), return H}}} (), a (var O a K.flagsban) K.flags.hasOwnProperty (O) && (K.flags [O] .match = függvény (a) {return a. Match (this.regex)}); K.setup = {renderelő: "html", pergésmentesítési: 100, arány: 1, supportsCanvas:! 1, supportsSVG:! 1, lineWrapRatio: .9, renderers: [ "html", "vászon", "svg"]}, K.dpr = függvény (a) {return a * K.setup.ratio}, K.vars = {megakadályozta:! 1, resizableImages: [], invisibleImages: {}, invisibleId : 0, visibilityCheckStarted:! 1, debounceTimer: null, gyorsítótár: {}, dataAttr: "data-src"}, függvény () {var a = 1, c = 1, d = null; d.getContext && - 1! = d.toDataURL (”image / png "). indexOf (" adatok: image / png ") && (K.setup.renderer =" vászon”, e = d.getContext ( "2d"), K.setup.supportsCanvas =! 0), K .setup.supportsCanvas && (a = b.devicePixelRatio || 1, c = e.webkitBackingStorePixelRatio || e.mozBackingStorePixelRatio || e.msBackingStorePixelRatio || e.oBackingStorePixelRatio || e.backingStorePixelRatio || 1), K.setup.ratio = a / c, document.createElementNS && document.createElementNS (F, "svg"). createSVGRect && (K.setup.renderer = "svg", K.setup.supportsSVG =! 0)} (), m (), v && v (függvény ( ) {K.vars.preempted || J.run (), b.addEventListener? (b.addEventListener ( "átméretezés", u,! 1), b.addEventListener ( "orientationchange", u,! 1)): b .attachEvent ("onresize", u), "object" == típusú b.Turbolinks && b.document.addEventListener ("oldal: változás",függvény () {függvény} ()}}, függvény (a) {függvény b (a) {függvény b (a)}} függvény c (a (v) = a (v) ) {(t || a.type === i || g [m] === l) && (d (), b ())} függvény d () {t? (g [s] (a, b) {setTimeout (c, j), a [s] (i, c, j)): a)} null == document.readyState && document.addEventListener && (document.addEventListener ("DOMContentLoaded", "b" függvény y () {document.removeEventListener ("DOMContentLoaded", y,! 1), document.readyState = "teljes"} ,! 1), document.readyState = "betöltés"), var g = a.document, g.documentElement, i = "terhelés", J =! 1, k = "a" + i, L = "teljes", m = "readyState", n = "attachEvent", o = "detachEvent", p =”addEventListener ", q =" DOMContentLoaded ", r =" onreadystatechange ", s =" removeEventListener ", t = p in g, u = j, v = j, w = (g, c, j), a [p] (i, c, j), máshol {g [n] (r, c), a [n próbáld ki {u = null == a.frameElement && h} fogd (x) {} u && u.doScroll &&! függvény z () {if (! v) {try {u.doScroll ("left")} fogadás (a) {return e (z, 50)} d (), b ()}} ()} return f.version = "1.4.0", f.isReady = függvény (a, b, c) {var d = c (4), e = függvény (a) {függvény b (a, b) {for ( var c in b) a [c] = b [c]; visszatér a} var c = 1, e = d.defclass ({konstruktor: függvény (a) {c ++, this.parent = null, this.children = }, this.id = c, this.name = "n" + c, null! = a && (this.name = a), this.x = 0, this.y = 0, this.z = 0, ez az. szélesség = 0, this.height = 0}, átméretezése: funkció (a, b) {null! = a &&(This.width = a), null! = B && (this.height = b)}, moveTo: funkció (a, b, c) {this.x = null! = A? A: this.x, this.y = null! = b? b: ez.y, ez.z = null! = c? c: ez.z} add: függvény (a) {var b = a.name; ha (null! = this.children már létezik: "+ b; this.children [b] = a, a.parent = ez}}), f = d (e, függvény (b) {ezt. konstruktor = függvény () {b.constructor.call (ez, "root"), this.properties = a}}), g = d (e, függvény (a) {függvény c (c, d) {if .constructor.call (ez, c), this.properties = {töltse ki: "# 000"}, null! = d) b (ezt a tulajdonságokat, d); egyébként ha (null! = c && "string"! = typeof c) dobja a "SceneGraph: érvénytelen csomópontnevet"} this.Group = d.extend (ez, {konstruktor: c, típus: "csoport"}) this.Rect = d.extend (ez, {constructor: c, type : "rect"}), this.Text = d.extend (e, {kivitelező: funkció (a) {c.call (e), this.properties.text = a}, írja be: "text"})}), h = új f; visszaadja ezt.Shape = g, this.root = h, ez} a.exports = e} függvény (a, b) { (függvény (a) {b.extend = függvény (a, b) {var c = {}, ha (var d in a) a.hasOwnProperty (d) && (c [d] = a [d] (c), b.cssProps = függvény (a) {var b = [] ; a (var c in a) a.hasOwnProperty (c) && b.push (c + ":" + a [c]); visszatérés b.join (";")}, b.encodeHtmlEntity = függvény (a) { (var b = [], c = 0, d = a.hossz-1; d> = 0; d -) c = a.charCodeAt (d), b.unshift (c> 128? ["& # , "b", "b", "c", "c", "" és "c" típus b? c = document.querySelectorAll (b): a.NodeList && b példány a.NodeList? c = b: a.Node && b példány a.Node? c = [b]: a.HTMLCollection && b instanceof a.(B, c), b.imageExists = függvény (a, b) {var c = új kép; c.onerror = funkció () {b.call (e,! 1)}, c.onload = function () {b.call (e,! 0)}, c.src = egy}, b.decodeHtmlEntity = funkció (a) { vissza a.replace (/ & # (\ d +); / g, függvény (a, b) {return String.fromCharCode (b)})}, b.dimensionCheck = függvény (a) {var b = {magasság: hívás (b, függvény () {return this} ())}, függvény (a) {var b = függvény () {}, c = Array.prototype.slice, d = függvény (a, d) {var e = b.prototype = "függvény" == típusú a? a.prototípus a, f = új b, g = f (h) = g [h], ha ("objektum" = "type of g") (var h in g) f (h) = g [h]; ! f.hasOwnProperty ("konstruktor")) return f; var i = f.constructor; visszatérés i.prototype = f, i}; d.defclass = függvény (a) {var b = a.constructor;prototípus = a, b}, d.extend = függvény (a, b) {vissza d (a, függvény (a) {return this.uber = a, b})}, a.exports = d} ;